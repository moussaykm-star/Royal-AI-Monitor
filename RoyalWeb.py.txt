import streamlit as st
import yfinance as yf
import pandas as pd
import numpy as np
import pandas_ta as ta
from sklearn.ensemble import RandomForestClassifier
from joblib import Parallel, delayed
import time

# ==============================================================================
# 1. Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ØµÙØ­Ø© (Ø´ÙƒÙ„ Ø§Ù„Ù…ÙˆÙ‚Ø¹)
# ==============================================================================
st.set_page_config(
    page_title="Royal AI Monitor",
    page_icon="ğŸ‘‘",
    layout="wide",
    initial_sidebar_state="collapsed"
)

# ØªØµÙ…ÙŠÙ… CSS Ø¨Ø³ÙŠØ· Ù„ØªØ­Ø³ÙŠÙ† Ø§Ù„Ù…Ø¸Ù‡Ø± (Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„Ù…Ø¸Ù„Ù…)
st.markdown("""
<style>
    .metric-card {
        background-color: #1e1e1e;
        border: 1px solid #333;
        padding: 15px;
        border-radius: 10px;
        margin-bottom: 10px;
    }
    .stApp {
        background-color: #0e1117;
    }
</style>
""", unsafe_allow_html=True)

st.title("ğŸ‘‘ Royal System AI: Live Market Monitor")
st.caption("Powered by Kernel Regression & Random Forest (10-Core Engine)")

# ==============================================================================
# 2. Ø§Ù„Ù…Ø­Ø±Ùƒ (Engine) - Ù†ÙØ³ Ø§Ù„Ù…Ù†Ø·Ù‚ Ø§Ù„Ù‚ÙˆÙŠ
# ==============================================================================
# Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„ÙƒØ§Ø´ Ù„ØªØ³Ø±ÙŠØ¹ Ø§Ù„ØªØ­Ù…ÙŠÙ„
@st.cache_resource
def get_model_params():
    return {'n_estimators': 100, 'min_samples_split': 10}

def calculate_kernel_chunk(indices, prices, h, r, lookback):
    results = {}
    prices_array = np.array(prices)
    for i in indices:
        if i < lookback:
            results[i] = np.nan
            continue 
        current_y_sum = 0.0
        current_w_sum = 0.0
        for j in range(lookback + 1):
            if i - j < 0: break
            price = prices_array[i - j]
            w = (1 + (j**2) / (2 * h**2 * r)) ** (-r)
            current_w_sum += w
            current_y_sum += (price * w)
        if current_w_sum != 0:
            results[i] = current_y_sum / current_w_sum
        else:
            results[i] = np.nan
    return results

def get_kernel_regression_parallel(price_list, h=8.0, r=8.0, lookback=20):
    # Ù†Ø³ØªØ®Ø¯Ù… Backend Ø¨Ø³ÙŠØ· Ù‡Ù†Ø§ Ù„Ù„ØªÙˆØ§ÙÙ‚ Ù…Ø¹ Ø§Ù„ÙˆÙŠØ¨
    total_len = len(price_list)
    indices = range(total_len)
    n_jobs = 4 # Ù†Ø®ÙÙ Ø§Ù„Ø­Ù…Ù„ Ù‚Ù„ÙŠÙ„Ø§Ù‹ Ù„Ù„Ø³ÙŠØ±ÙØ±Ø§Øª
    chunks = np.array_split(indices, n_jobs)
    
    results_list = Parallel(n_jobs=n_jobs, prefer="threads")(
        delayed(calculate_kernel_chunk)(chunk, price_list, h, r, lookback) for chunk in chunks
    )
    final_map = {}
    for res in results_list:
        final_map.update(res)
    sorted_results = [final_map[i] for i in range(total_len)]
    return sorted_results

def analyze_market(ticker_symbol, tf_name, config):
    try:
        ticker = yf.Ticker(ticker_symbol)
        df = ticker.history(period=config['period'], interval=config['interval'])
        
        if df.empty: return None
        df.dropna(inplace=True)
        if len(df) < 50: return None

        df.index = df.index.tz_localize(None)
        if 'Close' not in df.columns:
             df.columns = df.columns.droplevel(0) if isinstance(df.columns, pd.MultiIndex) else df.columns

        if tf_name == '4h' and config['interval'] == '1h':
            ohlc_dict = {'Open': 'first', 'High': 'max', 'Low': 'min', 'Close': 'last', 'Volume': 'sum'}
            df = df.resample('4h').apply(ohlc_dict).dropna()

        price_data = df['Close'].tolist()
        kernel_values = get_kernel_regression_parallel(price_data)
        df['Kernel_Line'] = kernel_values
        df['Kernel_Slope'] = df['Kernel_Line'].diff()

        df['Vol_MA'] = ta.sma(df['Volume'], length=20)
        df['RVOL'] = df['Volume'] / df['Vol_MA']
        df['EMA200'] = ta.ema(df['Close'], length=200)
        df['RSI'] = ta.rsi(df['Close'], length=14)

        cond_trend = [(df['Kernel_Slope'] > 0), (df['Kernel_Slope'] < 0)]
        df['S_Trend'] = np.select(cond_trend, [3, -3], 0)
        cond_vol = [(df['RVOL'] > 1.2), (df['RVOL'] < 0.8)] 
        df['S_Vol'] = np.select(cond_vol, [2, -1], 0)
        df['AI_Score'] = df['S_Trend'] + df['S_Vol']
        df.dropna(inplace=True)

        features = ['Kernel_Slope', 'RSI', 'RVOL', 'AI_Score', 'Close']
        X = df[features]
        y = (df['Close'].shift(-1) > df['Close']).astype(int)
        
        X = X[:-1]; y = y[:-1]
        
        model = RandomForestClassifier(n_estimators=100, min_samples_split=10, n_jobs=1, random_state=42)
        model.fit(X, y)

        last_row = df[features].iloc[-1].to_frame().T
        proba = model.predict_proba(last_row)[0]
        
        return {
            'timeframe': tf_name,
            'price': last_row['Close'].values[0],
            'bull_prob': proba[1] * 100,
            'bear_prob': proba[0] * 100,
            'rvol': last_row['RVOL'].values[0]
        }
    except Exception as e:
        return {'timeframe': tf_name, 'error': str(e)}

# ==============================================================================
# 3. ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ø¹Ø±Ø¶ (Dashboard)
# ==============================================================================

TIMEFRAMES = {
    '15m': {'period': '1mo', 'interval': '15m'},
    '30m': {'period': '1mo', 'interval': '30m'},
    '1h':  {'period': '1y',  'interval': '1h'},
    '4h':  {'period': '1y',  'interval': '1h'}
}

ASSETS = {
    'BITCOIN (BTC)': 'BTC-USD',
    'GOLD (FUTURES)': 'GC=F'
}

# Ø²Ø± ØªØ­Ø¯ÙŠØ« ÙŠØ¯ÙˆÙŠ
if st.button('ğŸ”„ Refresh Data Now'):
    st.rerun()

# Ø­Ø§ÙˆÙŠØ§Øª Ø§Ù„Ø¹Ø±Ø¶
col1, col2 = st.columns(2)

# Ø¹Ø±Ø¶ Ø§Ù„Ø¨ØªÙƒÙˆÙŠÙ†
with col1:
    st.subheader("ğŸŸ  Bitcoin (BTC)")
    btc_placeholder = st.empty()
    
    results_btc = []
    for tf, cfg in TIMEFRAMES.items():
        res = analyze_market(ASSETS['BITCOIN (BTC)'], tf, cfg)
        if res and 'error' not in res:
            results_btc.append(res)
    
    # Ø¹Ø±Ø¶ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ ÙƒØ¨Ø·Ø§Ù‚Ø§Øª
    for res in results_btc:
        bull = res['bull_prob']
        bear = res['bear_prob']
        
        if bull > 55:
            delta_color = "normal" 
            val_str = f"BUY ({bull:.1f}%)"
            icon = "ğŸŸ¢"
        elif bear > 55:
            delta_color = "inverse"
            val_str = f"SELL ({bear:.1f}%)"
            icon = "ğŸ”´"
        else:
            delta_color = "off"
            val_str = "WAIT"
            icon = "âš ï¸"

        st.metric(
            label=f"{res['timeframe']} - Price: ${res['price']:.2f}",
            value=f"{icon} {val_str}",
            delta=f"RVOL: {res['rvol']:.2f}",
            delta_color=delta_color
        )
    
    if not results_btc:
        st.error("Could not fetch BTC data.")

# Ø¹Ø±Ø¶ Ø§Ù„Ø°Ù‡Ø¨
with col2:
    st.subheader("ğŸŸ¡ Gold (Futures)")
    gold_placeholder = st.empty()

    results_gold = []
    for tf, cfg in TIMEFRAMES.items():
        res = analyze_market(ASSETS['GOLD (FUTURES)'], tf, cfg)
        if res and 'error' not in res:
            results_gold.append(res)
            
    for res in results_gold:
        bull = res['bull_prob']
        bear = res['bear_prob']
        
        if bull > 55:
            delta_color = "normal"
            val_str = f"BUY ({bull:.1f}%)"
            icon = "ğŸŸ¢"
        elif bear > 55:
            delta_color = "inverse"
            val_str = f"SELL ({bear:.1f}%)"
            icon = "ğŸ”´"
        else:
            delta_color = "off"
            val_str = "WAIT"
            icon = "âš ï¸"

        st.metric(
            label=f"{res['timeframe']} - Price: ${res['price']:.2f}",
            value=f"{icon} {val_str}",
            delta=f"RVOL: {res['rvol']:.2f}",
            delta_color=delta_color
        )
        
    if not results_gold:
        st.warning("Gold Market might be closed.")

st.markdown("---")
st.write(f"Last Update: {time.strftime('%H:%M:%S')}")

# Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªØ´ØºÙŠÙ„ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ (ÙƒÙ„ 60 Ø«Ø§Ù†ÙŠØ©)
time.sleep(60)
st.rerun()